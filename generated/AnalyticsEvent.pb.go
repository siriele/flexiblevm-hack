// Code generated by protoc-gen-go.
// source: AnalyticsEvent.proto
// DO NOT EDIT!

/*
Package generated is a generated protocol buffer package.

It is generated from these files:
	AnalyticsEvent.proto
	TangramAnalyticsEvent.proto

It has these top-level messages:
	EventMetadata
	DeviceInfo
	UserProperties
	PlayerState
	Counter
	SessionEvent
	LevelEvent
	LoginEvent
	LoginSessionEvent
	ProfileEditEvent
	ConnectEvent
	ClickEvent
	SetupEvent
	PromoEvent
	CrossAppShowEvent
	CrossAppClickEvent
	StateChangeEvent
	TimedData
	InLevelData
	AnalyticsEvent
	EventBatch
	TangramSessionEvent
	TangramLevelEvent
	TangramUserProperties
	TangramPlayerState
*/
package generated

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Game id, or 'playOsmo'. It could also be an enum.
// We need to be able to easily select all games, either by prefix
// ('game_...', or enum value range)
type EventMetadata_Source int32

const (
	EventMetadata_PLAYOSMO         EventMetadata_Source = 1
	EventMetadata_MYOSMO           EventMetadata_Source = 2
	EventMetadata_GAME_TANGRAM     EventMetadata_Source = 101
	EventMetadata_GAME_WORDS       EventMetadata_Source = 102
	EventMetadata_GAME_NEWTON      EventMetadata_Source = 103
	EventMetadata_GAME_MASTERPIECE EventMetadata_Source = 104
	EventMetadata_GAME_NUMBERS     EventMetadata_Source = 105
	EventMetadata_GAME_CODING      EventMetadata_Source = 106
	EventMetadata_GAME_MONSTER     EventMetadata_Source = 107
)

var EventMetadata_Source_name = map[int32]string{
	1:   "PLAYOSMO",
	2:   "MYOSMO",
	101: "GAME_TANGRAM",
	102: "GAME_WORDS",
	103: "GAME_NEWTON",
	104: "GAME_MASTERPIECE",
	105: "GAME_NUMBERS",
	106: "GAME_CODING",
	107: "GAME_MONSTER",
}
var EventMetadata_Source_value = map[string]int32{
	"PLAYOSMO":         1,
	"MYOSMO":           2,
	"GAME_TANGRAM":     101,
	"GAME_WORDS":       102,
	"GAME_NEWTON":      103,
	"GAME_MASTERPIECE": 104,
	"GAME_NUMBERS":     105,
	"GAME_CODING":      106,
	"GAME_MONSTER":     107,
}

func (x EventMetadata_Source) Enum() *EventMetadata_Source {
	p := new(EventMetadata_Source)
	*p = x
	return p
}
func (x EventMetadata_Source) String() string {
	return proto.EnumName(EventMetadata_Source_name, int32(x))
}
func (x *EventMetadata_Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EventMetadata_Source_value, data, "EventMetadata_Source")
	if err != nil {
		return err
	}
	*x = EventMetadata_Source(value)
	return nil
}
func (EventMetadata_Source) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// Event Metadata
type EventMetadata struct {
	Source *EventMetadata_Source `protobuf:"varint,1,opt,name=source,enum=generated.EventMetadata_Source" json:"source,omitempty"`
	// Version should match the software version number for games and release
	// branch for website.
	SourceVersion *string `protobuf:"bytes,2,opt,name=source_version,json=sourceVersion" json:"source_version,omitempty"`
	// A session is defined by a contiguous length of interaction with the App
	// with constant user id, profile id, game id, device id.
	// So we should just need a short id to disambiguate, given the rest.
	// client send a timestamp here to make sure this is a unique value that doesn't
	// get reset when the app is uninstalled, otherwise would need to store in keychain to make sure
	// it persists
	SessionId *int64 `protobuf:"varint,3,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	// Per session event counter, to be able to e.g. detect lost events
	EventCounter *int32 `protobuf:"varint,4,opt,name=event_counter,json=eventCounter" json:"event_counter,omitempty"`
	// User information. Only set if the user is logged in / is using profiles.
	UserId    *string `protobuf:"bytes,6,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	ProfileId *string `protobuf:"bytes,7,opt,name=profile_id,json=profileId" json:"profile_id,omitempty"`
	// unique identifier stored in a way that is the same for the device across apps/reinstall
	// maybe keep mixpanel id when available for consistency with existing data
	DeviceId *string `protobuf:"bytes,8,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// the user's distinct id from mixpanel where applicable so we can match our mixpanel data to the right user
	// mixpanel's ids could potentially be different per game, so we don't want to try to count on initializing our device id
	// that should be the same across all our apps and being able to properly attach all the old data to the correct user
	MixpanelId *string `protobuf:"bytes,9,opt,name=mixpanel_id,json=mixpanelId" json:"mixpanel_id,omitempty"`
	// Millisecond Unix timestamp.
	ClientTime *int64 `protobuf:"varint,10,opt,name=client_time,json=clientTime" json:"client_time,omitempty"`
	// Millisecond Unix timestamp, only populated once the event reaches the server.
	ServerTime       *int64 `protobuf:"varint,11,opt,name=server_time,json=serverTime" json:"server_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EventMetadata) Reset()                    { *m = EventMetadata{} }
func (m *EventMetadata) String() string            { return proto.CompactTextString(m) }
func (*EventMetadata) ProtoMessage()               {}
func (*EventMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EventMetadata) GetSource() EventMetadata_Source {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return EventMetadata_PLAYOSMO
}

func (m *EventMetadata) GetSourceVersion() string {
	if m != nil && m.SourceVersion != nil {
		return *m.SourceVersion
	}
	return ""
}

func (m *EventMetadata) GetSessionId() int64 {
	if m != nil && m.SessionId != nil {
		return *m.SessionId
	}
	return 0
}

func (m *EventMetadata) GetEventCounter() int32 {
	if m != nil && m.EventCounter != nil {
		return *m.EventCounter
	}
	return 0
}

func (m *EventMetadata) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *EventMetadata) GetProfileId() string {
	if m != nil && m.ProfileId != nil {
		return *m.ProfileId
	}
	return ""
}

func (m *EventMetadata) GetDeviceId() string {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return ""
}

func (m *EventMetadata) GetMixpanelId() string {
	if m != nil && m.MixpanelId != nil {
		return *m.MixpanelId
	}
	return ""
}

func (m *EventMetadata) GetClientTime() int64 {
	if m != nil && m.ClientTime != nil {
		return *m.ClientTime
	}
	return 0
}

func (m *EventMetadata) GetServerTime() int64 {
	if m != nil && m.ServerTime != nil {
		return *m.ServerTime
	}
	return 0
}

// More specific device information.
type DeviceInfo struct {
	Platform         *string `protobuf:"bytes,1,opt,name=platform" json:"platform,omitempty"`
	Model            *string `protobuf:"bytes,2,opt,name=model" json:"model,omitempty"`
	Os               *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	ScreenWidth      *int32  `protobuf:"varint,4,opt,name=screen_width,json=screenWidth" json:"screen_width,omitempty"`
	ScreenHeight     *int32  `protobuf:"varint,5,opt,name=screen_height,json=screenHeight" json:"screen_height,omitempty"`
	Language         *string `protobuf:"bytes,6,opt,name=language" json:"language,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DeviceInfo) Reset()                    { *m = DeviceInfo{} }
func (m *DeviceInfo) String() string            { return proto.CompactTextString(m) }
func (*DeviceInfo) ProtoMessage()               {}
func (*DeviceInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeviceInfo) GetPlatform() string {
	if m != nil && m.Platform != nil {
		return *m.Platform
	}
	return ""
}

func (m *DeviceInfo) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *DeviceInfo) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *DeviceInfo) GetScreenWidth() int32 {
	if m != nil && m.ScreenWidth != nil {
		return *m.ScreenWidth
	}
	return 0
}

func (m *DeviceInfo) GetScreenHeight() int32 {
	if m != nil && m.ScreenHeight != nil {
		return *m.ScreenHeight
	}
	return 0
}

func (m *DeviceInfo) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

type UserProperties struct {
	// whether or not the user has ever successfully gone through setup without skipping on this device
	// (we should know from this that they have the hardware)
	HaveSetup *bool `protobuf:"varint,1,opt,name=have_setup,json=haveSetup" json:"have_setup,omitempty"`
	// the last language selected to use on the device
	LastLanguage *string `protobuf:"bytes,2,opt,name=last_language,json=lastLanguage" json:"last_language,omitempty"`
	// whether the user has ever replied yes to having the osmo hardware
	HaveHardware *bool `protobuf:"varint,3,opt,name=have_hardware,json=haveHardware" json:"have_hardware,omitempty"`
	// whether the user has ever replied yes to having game specific hardware (numbers or coding tiles)
	HaveExtraHardware *bool `protobuf:"varint,4,opt,name=have_extra_hardware,json=haveExtraHardware" json:"have_extra_hardware,omitempty"`
	// total number of sessions played on this device
	SessionCount *int32 `protobuf:"varint,5,opt,name=session_count,json=sessionCount" json:"session_count,omitempty"`
	// total playtime on this device
	PlaytimeMs *int32 `protobuf:"varint,6,opt,name=playtime_ms,json=playtimeMs" json:"playtime_ms,omitempty"`
	// total time spent in levels in this game
	LeveltimeMs *int32 `protobuf:"varint,7,opt,name=leveltime_ms,json=leveltimeMs" json:"leveltime_ms,omitempty"`
	// total number of levels started on this device
	LevelStarts *int32 `protobuf:"varint,8,opt,name=level_starts,json=levelStarts" json:"level_starts,omitempty"`
	// total number of levels whose end was detected, so we can make sure we aren't missing
	// any analytics for in progress levels
	LevelEnds *int32 `protobuf:"varint,9,opt,name=level_ends,json=levelEnds" json:"level_ends,omitempty"`
	// number of profiles set up for the account logged in on the device
	Profiles *int32 `protobuf:"varint,10,opt,name=profiles" json:"profiles,omitempty"`
	// last value for mirror check quality on the device
	LastMirror *int32 `protobuf:"varint,11,opt,name=last_mirror,json=lastMirror" json:"last_mirror,omitempty"`
	// last vision debug string for this device
	LastSetupDebug *string `protobuf:"bytes,12,opt,name=last_setup_debug,json=lastSetupDebug" json:"last_setup_debug,omitempty"`
	// number of times achievements dialog was opened on the device so we can get a sense of
	// how much people care about them
	AchievementsOpened *int32 `protobuf:"varint,13,opt,name=achievements_opened,json=achievementsOpened" json:"achievements_opened,omitempty"`
	// last state the game was in when closed on this device so we can get a sense of
	// where people are leaving
	LastState                    *string `protobuf:"bytes,14,opt,name=last_state,json=lastState" json:"last_state,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *UserProperties) Reset()                    { *m = UserProperties{} }
func (m *UserProperties) String() string            { return proto.CompactTextString(m) }
func (*UserProperties) ProtoMessage()               {}
func (*UserProperties) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

var extRange_UserProperties = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*UserProperties) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_UserProperties
}

func (m *UserProperties) GetHaveSetup() bool {
	if m != nil && m.HaveSetup != nil {
		return *m.HaveSetup
	}
	return false
}

func (m *UserProperties) GetLastLanguage() string {
	if m != nil && m.LastLanguage != nil {
		return *m.LastLanguage
	}
	return ""
}

func (m *UserProperties) GetHaveHardware() bool {
	if m != nil && m.HaveHardware != nil {
		return *m.HaveHardware
	}
	return false
}

func (m *UserProperties) GetHaveExtraHardware() bool {
	if m != nil && m.HaveExtraHardware != nil {
		return *m.HaveExtraHardware
	}
	return false
}

func (m *UserProperties) GetSessionCount() int32 {
	if m != nil && m.SessionCount != nil {
		return *m.SessionCount
	}
	return 0
}

func (m *UserProperties) GetPlaytimeMs() int32 {
	if m != nil && m.PlaytimeMs != nil {
		return *m.PlaytimeMs
	}
	return 0
}

func (m *UserProperties) GetLeveltimeMs() int32 {
	if m != nil && m.LeveltimeMs != nil {
		return *m.LeveltimeMs
	}
	return 0
}

func (m *UserProperties) GetLevelStarts() int32 {
	if m != nil && m.LevelStarts != nil {
		return *m.LevelStarts
	}
	return 0
}

func (m *UserProperties) GetLevelEnds() int32 {
	if m != nil && m.LevelEnds != nil {
		return *m.LevelEnds
	}
	return 0
}

func (m *UserProperties) GetProfiles() int32 {
	if m != nil && m.Profiles != nil {
		return *m.Profiles
	}
	return 0
}

func (m *UserProperties) GetLastMirror() int32 {
	if m != nil && m.LastMirror != nil {
		return *m.LastMirror
	}
	return 0
}

func (m *UserProperties) GetLastSetupDebug() string {
	if m != nil && m.LastSetupDebug != nil {
		return *m.LastSetupDebug
	}
	return ""
}

func (m *UserProperties) GetAchievementsOpened() int32 {
	if m != nil && m.AchievementsOpened != nil {
		return *m.AchievementsOpened
	}
	return 0
}

func (m *UserProperties) GetLastState() string {
	if m != nil && m.LastState != nil {
		return *m.LastState
	}
	return ""
}

type PlayerState struct {
	// number of achievements this profile has earned
	AchievementsCompleted        *int32 `protobuf:"varint,1,opt,name=achievements_completed,json=achievementsCompleted" json:"achievements_completed,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *PlayerState) Reset()                    { *m = PlayerState{} }
func (m *PlayerState) String() string            { return proto.CompactTextString(m) }
func (*PlayerState) ProtoMessage()               {}
func (*PlayerState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

var extRange_PlayerState = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*PlayerState) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_PlayerState
}

func (m *PlayerState) GetAchievementsCompleted() int32 {
	if m != nil && m.AchievementsCompleted != nil {
		return *m.AchievementsCompleted
	}
	return 0
}

// generic way of storing the number of times something happened
type Counter struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Count            *int32  `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Counter) Reset()                    { *m = Counter{} }
func (m *Counter) String() string            { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()               {}
func (*Counter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Counter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Counter) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type SessionEvent struct {
	Device           *DeviceInfo     `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	PropsToSet       *UserProperties `protobuf:"bytes,2,opt,name=props_to_set,json=propsToSet" json:"props_to_set,omitempty"`
	PropsToIncrement *UserProperties `protobuf:"bytes,3,opt,name=props_to_increment,json=propsToIncrement" json:"props_to_increment,omitempty"`
	PlayerState      *PlayerState    `protobuf:"bytes,4,opt,name=player_state,json=playerState" json:"player_state,omitempty"`
	// Common game session values aggregated over the session.
	LeveltimeMs                  *int32  `protobuf:"varint,5,opt,name=leveltime_ms,json=leveltimeMs" json:"leveltime_ms,omitempty"`
	Language                     *string `protobuf:"bytes,6,opt,name=language" json:"language,omitempty"`
	LastState                    *string `protobuf:"bytes,7,opt,name=last_state,json=lastState" json:"last_state,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *SessionEvent) Reset()                    { *m = SessionEvent{} }
func (m *SessionEvent) String() string            { return proto.CompactTextString(m) }
func (*SessionEvent) ProtoMessage()               {}
func (*SessionEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

var extRange_SessionEvent = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*SessionEvent) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_SessionEvent
}

func (m *SessionEvent) GetDevice() *DeviceInfo {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *SessionEvent) GetPropsToSet() *UserProperties {
	if m != nil {
		return m.PropsToSet
	}
	return nil
}

func (m *SessionEvent) GetPropsToIncrement() *UserProperties {
	if m != nil {
		return m.PropsToIncrement
	}
	return nil
}

func (m *SessionEvent) GetPlayerState() *PlayerState {
	if m != nil {
		return m.PlayerState
	}
	return nil
}

func (m *SessionEvent) GetLeveltimeMs() int32 {
	if m != nil && m.LeveltimeMs != nil {
		return *m.LeveltimeMs
	}
	return 0
}

func (m *SessionEvent) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *SessionEvent) GetLastState() string {
	if m != nil && m.LastState != nil {
		return *m.LastState
	}
	return ""
}

type LevelEvent struct {
	// unique identifier for this instance of a level so that events that happen during it can be
	// tied to it.  should use the timestamp the level was created to make sure it's unique including
	// for levels that can persist after leaving and coming back/across sessions
	LevelUniqueId *int64 `protobuf:"varint,1,opt,name=level_unique_id,json=levelUniqueId" json:"level_unique_id,omitempty"`
	// identify which level/puzzle they are playing
	LevelId *string `protobuf:"bytes,2,opt,name=level_id,json=levelId" json:"level_id,omitempty"`
	// whether or not the level was successfully solved.  this is different from the completed field
	// on the timed event which just indicates if it was completed in some way, not necessarily successfully
	Solved                       *bool `protobuf:"varint,3,opt,name=solved" json:"solved,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *LevelEvent) Reset()                    { *m = LevelEvent{} }
func (m *LevelEvent) String() string            { return proto.CompactTextString(m) }
func (*LevelEvent) ProtoMessage()               {}
func (*LevelEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

var extRange_LevelEvent = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*LevelEvent) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_LevelEvent
}

func (m *LevelEvent) GetLevelUniqueId() int64 {
	if m != nil && m.LevelUniqueId != nil {
		return *m.LevelUniqueId
	}
	return 0
}

func (m *LevelEvent) GetLevelId() string {
	if m != nil && m.LevelId != nil {
		return *m.LevelId
	}
	return ""
}

func (m *LevelEvent) GetSolved() bool {
	if m != nil && m.Solved != nil {
		return *m.Solved
	}
	return false
}

type LoginEvent struct {
	Source           *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Resumed          *bool   `protobuf:"varint,2,opt,name=resumed" json:"resumed,omitempty"`
	Success          *bool   `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	NumAccounts      *int32  `protobuf:"varint,4,opt,name=num_accounts,json=numAccounts" json:"num_accounts,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoginEvent) Reset()                    { *m = LoginEvent{} }
func (m *LoginEvent) String() string            { return proto.CompactTextString(m) }
func (*LoginEvent) ProtoMessage()               {}
func (*LoginEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LoginEvent) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *LoginEvent) GetResumed() bool {
	if m != nil && m.Resumed != nil {
		return *m.Resumed
	}
	return false
}

func (m *LoginEvent) GetSuccess() bool {
	if m != nil && m.Success != nil {
		return *m.Success
	}
	return false
}

func (m *LoginEvent) GetNumAccounts() int32 {
	if m != nil && m.NumAccounts != nil {
		return *m.NumAccounts
	}
	return 0
}

type LoginSessionEvent struct {
	Source           *string    `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Attempts         *int32     `protobuf:"varint,2,opt,name=attempts" json:"attempts,omitempty"`
	Success          *bool      `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	Closed           *bool      `protobuf:"varint,4,opt,name=closed" json:"closed,omitempty"`
	Errors           []*Counter `protobuf:"bytes,5,rep,name=errors" json:"errors,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *LoginSessionEvent) Reset()                    { *m = LoginSessionEvent{} }
func (m *LoginSessionEvent) String() string            { return proto.CompactTextString(m) }
func (*LoginSessionEvent) ProtoMessage()               {}
func (*LoginSessionEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LoginSessionEvent) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *LoginSessionEvent) GetAttempts() int32 {
	if m != nil && m.Attempts != nil {
		return *m.Attempts
	}
	return 0
}

func (m *LoginSessionEvent) GetSuccess() bool {
	if m != nil && m.Success != nil {
		return *m.Success
	}
	return false
}

func (m *LoginSessionEvent) GetClosed() bool {
	if m != nil && m.Closed != nil {
		return *m.Closed
	}
	return false
}

func (m *LoginSessionEvent) GetErrors() []*Counter {
	if m != nil {
		return m.Errors
	}
	return nil
}

type ProfileEditEvent struct {
	Forced           *bool   `protobuf:"varint,1,opt,name=forced" json:"forced,omitempty"`
	NewProfile       *bool   `protobuf:"varint,2,opt,name=new_profile,json=newProfile" json:"new_profile,omitempty"`
	Avatar           *int32  `protobuf:"varint,3,opt,name=avatar" json:"avatar,omitempty"`
	Color            *int32  `protobuf:"varint,4,opt,name=color" json:"color,omitempty"`
	Step             *string `protobuf:"bytes,5,opt,name=step" json:"step,omitempty"`
	Confirm          *bool   `protobuf:"varint,6,opt,name=confirm" json:"confirm,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ProfileEditEvent) Reset()                    { *m = ProfileEditEvent{} }
func (m *ProfileEditEvent) String() string            { return proto.CompactTextString(m) }
func (*ProfileEditEvent) ProtoMessage()               {}
func (*ProfileEditEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ProfileEditEvent) GetForced() bool {
	if m != nil && m.Forced != nil {
		return *m.Forced
	}
	return false
}

func (m *ProfileEditEvent) GetNewProfile() bool {
	if m != nil && m.NewProfile != nil {
		return *m.NewProfile
	}
	return false
}

func (m *ProfileEditEvent) GetAvatar() int32 {
	if m != nil && m.Avatar != nil {
		return *m.Avatar
	}
	return 0
}

func (m *ProfileEditEvent) GetColor() int32 {
	if m != nil && m.Color != nil {
		return *m.Color
	}
	return 0
}

func (m *ProfileEditEvent) GetStep() string {
	if m != nil && m.Step != nil {
		return *m.Step
	}
	return ""
}

func (m *ProfileEditEvent) GetConfirm() bool {
	if m != nil && m.Confirm != nil {
		return *m.Confirm
	}
	return false
}

type ConnectEvent struct {
	Autofill         *bool  `protobuf:"varint,1,opt,name=autofill" json:"autofill,omitempty"`
	UsedInfo         *int32 `protobuf:"varint,2,opt,name=used_info,json=usedInfo" json:"used_info,omitempty"`
	UsedSkip         *int32 `protobuf:"varint,3,opt,name=used_skip,json=usedSkip" json:"used_skip,omitempty"`
	NetworkFails     *int32 `protobuf:"varint,4,opt,name=network_fails,json=networkFails" json:"network_fails,omitempty"`
	InvalidFails     *int32 `protobuf:"varint,5,opt,name=invalid_fails,json=invalidFails" json:"invalid_fails,omitempty"`
	UnknownFails     *int32 `protobuf:"varint,6,opt,name=unknown_fails,json=unknownFails" json:"unknown_fails,omitempty"`
	Success          *bool  `protobuf:"varint,7,opt,name=success" json:"success,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConnectEvent) Reset()                    { *m = ConnectEvent{} }
func (m *ConnectEvent) String() string            { return proto.CompactTextString(m) }
func (*ConnectEvent) ProtoMessage()               {}
func (*ConnectEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ConnectEvent) GetAutofill() bool {
	if m != nil && m.Autofill != nil {
		return *m.Autofill
	}
	return false
}

func (m *ConnectEvent) GetUsedInfo() int32 {
	if m != nil && m.UsedInfo != nil {
		return *m.UsedInfo
	}
	return 0
}

func (m *ConnectEvent) GetUsedSkip() int32 {
	if m != nil && m.UsedSkip != nil {
		return *m.UsedSkip
	}
	return 0
}

func (m *ConnectEvent) GetNetworkFails() int32 {
	if m != nil && m.NetworkFails != nil {
		return *m.NetworkFails
	}
	return 0
}

func (m *ConnectEvent) GetInvalidFails() int32 {
	if m != nil && m.InvalidFails != nil {
		return *m.InvalidFails
	}
	return 0
}

func (m *ConnectEvent) GetUnknownFails() int32 {
	if m != nil && m.UnknownFails != nil {
		return *m.UnknownFails
	}
	return 0
}

func (m *ConnectEvent) GetSuccess() bool {
	if m != nil && m.Success != nil {
		return *m.Success
	}
	return false
}

type ClickEvent struct {
	ObjClicked       *string `protobuf:"bytes,1,opt,name=obj_clicked,json=objClicked" json:"obj_clicked,omitempty"`
	CurScreen        *string `protobuf:"bytes,2,opt,name=cur_screen,json=curScreen" json:"cur_screen,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ClickEvent) Reset()                    { *m = ClickEvent{} }
func (m *ClickEvent) String() string            { return proto.CompactTextString(m) }
func (*ClickEvent) ProtoMessage()               {}
func (*ClickEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ClickEvent) GetObjClicked() string {
	if m != nil && m.ObjClicked != nil {
		return *m.ObjClicked
	}
	return ""
}

func (m *ClickEvent) GetCurScreen() string {
	if m != nil && m.CurScreen != nil {
		return *m.CurScreen
	}
	return ""
}

type SetupEvent struct {
	SetupStatus      *string `protobuf:"bytes,1,opt,name=setup_status,json=setupStatus" json:"setup_status,omitempty"`
	PaperStatus      *string `protobuf:"bytes,2,opt,name=paper_status,json=paperStatus" json:"paper_status,omitempty"`
	MirrorQuality    *int32  `protobuf:"varint,3,opt,name=mirror_quality,json=mirrorQuality" json:"mirror_quality,omitempty"`
	SetupDebug       *string `protobuf:"bytes,4,opt,name=setup_debug,json=setupDebug" json:"setup_debug,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SetupEvent) Reset()                    { *m = SetupEvent{} }
func (m *SetupEvent) String() string            { return proto.CompactTextString(m) }
func (*SetupEvent) ProtoMessage()               {}
func (*SetupEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SetupEvent) GetSetupStatus() string {
	if m != nil && m.SetupStatus != nil {
		return *m.SetupStatus
	}
	return ""
}

func (m *SetupEvent) GetPaperStatus() string {
	if m != nil && m.PaperStatus != nil {
		return *m.PaperStatus
	}
	return ""
}

func (m *SetupEvent) GetMirrorQuality() int32 {
	if m != nil && m.MirrorQuality != nil {
		return *m.MirrorQuality
	}
	return 0
}

func (m *SetupEvent) GetSetupDebug() string {
	if m != nil && m.SetupDebug != nil {
		return *m.SetupDebug
	}
	return ""
}

type PromoEvent struct {
	PromoKey         *string `protobuf:"bytes,1,opt,name=promo_key,json=promoKey" json:"promo_key,omitempty"`
	Taps             *int32  `protobuf:"varint,2,opt,name=taps" json:"taps,omitempty"`
	Views            *int32  `protobuf:"varint,3,opt,name=views" json:"views,omitempty"`
	Clicks           *int32  `protobuf:"varint,4,opt,name=clicks" json:"clicks,omitempty"`
	Auto             *int32  `protobuf:"varint,5,opt,name=auto" json:"auto,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PromoEvent) Reset()                    { *m = PromoEvent{} }
func (m *PromoEvent) String() string            { return proto.CompactTextString(m) }
func (*PromoEvent) ProtoMessage()               {}
func (*PromoEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *PromoEvent) GetPromoKey() string {
	if m != nil && m.PromoKey != nil {
		return *m.PromoKey
	}
	return ""
}

func (m *PromoEvent) GetTaps() int32 {
	if m != nil && m.Taps != nil {
		return *m.Taps
	}
	return 0
}

func (m *PromoEvent) GetViews() int32 {
	if m != nil && m.Views != nil {
		return *m.Views
	}
	return 0
}

func (m *PromoEvent) GetClicks() int32 {
	if m != nil && m.Clicks != nil {
		return *m.Clicks
	}
	return 0
}

func (m *PromoEvent) GetAuto() int32 {
	if m != nil && m.Auto != nil {
		return *m.Auto
	}
	return 0
}

// sent each time a cross promo is shown
type CrossAppShowEvent struct {
	AppId            *string `protobuf:"bytes,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CrossAppShowEvent) Reset()                    { *m = CrossAppShowEvent{} }
func (m *CrossAppShowEvent) String() string            { return proto.CompactTextString(m) }
func (*CrossAppShowEvent) ProtoMessage()               {}
func (*CrossAppShowEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CrossAppShowEvent) GetAppId() string {
	if m != nil && m.AppId != nil {
		return *m.AppId
	}
	return ""
}

// sent each time the cross promo is clicked
type CrossAppClickEvent struct {
	AppId            *string `protobuf:"bytes,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CrossAppClickEvent) Reset()                    { *m = CrossAppClickEvent{} }
func (m *CrossAppClickEvent) String() string            { return proto.CompactTextString(m) }
func (*CrossAppClickEvent) ProtoMessage()               {}
func (*CrossAppClickEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *CrossAppClickEvent) GetAppId() string {
	if m != nil && m.AppId != nil {
		return *m.AppId
	}
	return ""
}

// sent from each game every time the main state machine changes states
type StateChangeEvent struct {
	NewState         *string `protobuf:"bytes,1,opt,name=new_state,json=newState" json:"new_state,omitempty"`
	PrevState        *string `protobuf:"bytes,2,opt,name=prev_state,json=prevState" json:"prev_state,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StateChangeEvent) Reset()                    { *m = StateChangeEvent{} }
func (m *StateChangeEvent) String() string            { return proto.CompactTextString(m) }
func (*StateChangeEvent) ProtoMessage()               {}
func (*StateChangeEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *StateChangeEvent) GetNewState() string {
	if m != nil && m.NewState != nil {
		return *m.NewState
	}
	return ""
}

func (m *StateChangeEvent) GetPrevState() string {
	if m != nil && m.PrevState != nil {
		return *m.PrevState
	}
	return ""
}

// information about events that happen over an amount of time and we want to capture the duration
type TimedData struct {
	DurationMs       *int32  `protobuf:"varint,1,opt,name=duration_ms,json=durationMs" json:"duration_ms,omitempty"`
	Completed        *bool   `protobuf:"varint,2,opt,name=completed" json:"completed,omitempty"`
	TimeReadable     *string `protobuf:"bytes,3,opt,name=time_readable,json=timeReadable" json:"time_readable,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TimedData) Reset()                    { *m = TimedData{} }
func (m *TimedData) String() string            { return proto.CompactTextString(m) }
func (*TimedData) ProtoMessage()               {}
func (*TimedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *TimedData) GetDurationMs() int32 {
	if m != nil && m.DurationMs != nil {
		return *m.DurationMs
	}
	return 0
}

func (m *TimedData) GetCompleted() bool {
	if m != nil && m.Completed != nil {
		return *m.Completed
	}
	return false
}

func (m *TimedData) GetTimeReadable() string {
	if m != nil && m.TimeReadable != nil {
		return *m.TimeReadable
	}
	return ""
}

// information about events that happen during a level with the id of the level they should be tied to
type InLevelData struct {
	LevelUniqueId    *int64 `protobuf:"varint,1,opt,name=level_unique_id,json=levelUniqueId" json:"level_unique_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InLevelData) Reset()                    { *m = InLevelData{} }
func (m *InLevelData) String() string            { return proto.CompactTextString(m) }
func (*InLevelData) ProtoMessage()               {}
func (*InLevelData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *InLevelData) GetLevelUniqueId() int64 {
	if m != nil && m.LevelUniqueId != nil {
		return *m.LevelUniqueId
	}
	return 0
}

// An event.
type AnalyticsEvent struct {
	// Event metadata.
	Metadata *EventMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Event type: more specific than source.
	// "session_start" for session_start event, "tangram" for tangram event, etc.
	EventType *string `protobuf:"bytes,2,opt,name=event_type,json=eventType" json:"event_type,omitempty"`
	// information for events that have durations associated with them
	Timed *TimedData `protobuf:"bytes,3,opt,name=timed" json:"timed,omitempty"`
	// information about events that happen during a level we want to tie them to
	InLevel *InLevelData `protobuf:"bytes,4,opt,name=in_level,json=inLevel" json:"in_level,omitempty"`
	// One of the following
	Session                      *SessionEvent       `protobuf:"bytes,100,opt,name=session" json:"session,omitempty"`
	Level                        *LevelEvent         `protobuf:"bytes,101,opt,name=level" json:"level,omitempty"`
	Login                        *LoginEvent         `protobuf:"bytes,102,opt,name=login" json:"login,omitempty"`
	ProfileEdit                  *ProfileEditEvent   `protobuf:"bytes,103,opt,name=profile_edit,json=profileEdit" json:"profile_edit,omitempty"`
	Promo                        *PromoEvent         `protobuf:"bytes,104,opt,name=promo" json:"promo,omitempty"`
	XAppShow                     *CrossAppShowEvent  `protobuf:"bytes,105,opt,name=x_app_show,json=xAppShow" json:"x_app_show,omitempty"`
	XAppClick                    *CrossAppClickEvent `protobuf:"bytes,106,opt,name=x_app_click,json=xAppClick" json:"x_app_click,omitempty"`
	StateChange                  *StateChangeEvent   `protobuf:"bytes,107,opt,name=state_change,json=stateChange" json:"state_change,omitempty"`
	Setup                        *SetupEvent         `protobuf:"bytes,108,opt,name=setup" json:"setup,omitempty"`
	Click                        *ClickEvent         `protobuf:"bytes,109,opt,name=click" json:"click,omitempty"`
	LoginSession                 *LoginSessionEvent  `protobuf:"bytes,110,opt,name=login_session,json=loginSession" json:"login_session,omitempty"`
	Connect                      *ConnectEvent       `protobuf:"bytes,111,opt,name=connect" json:"connect,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *AnalyticsEvent) Reset()                    { *m = AnalyticsEvent{} }
func (m *AnalyticsEvent) String() string            { return proto.CompactTextString(m) }
func (*AnalyticsEvent) ProtoMessage()               {}
func (*AnalyticsEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

var extRange_AnalyticsEvent = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*AnalyticsEvent) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_AnalyticsEvent
}

func (m *AnalyticsEvent) GetMetadata() *EventMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *AnalyticsEvent) GetEventType() string {
	if m != nil && m.EventType != nil {
		return *m.EventType
	}
	return ""
}

func (m *AnalyticsEvent) GetTimed() *TimedData {
	if m != nil {
		return m.Timed
	}
	return nil
}

func (m *AnalyticsEvent) GetInLevel() *InLevelData {
	if m != nil {
		return m.InLevel
	}
	return nil
}

func (m *AnalyticsEvent) GetSession() *SessionEvent {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *AnalyticsEvent) GetLevel() *LevelEvent {
	if m != nil {
		return m.Level
	}
	return nil
}

func (m *AnalyticsEvent) GetLogin() *LoginEvent {
	if m != nil {
		return m.Login
	}
	return nil
}

func (m *AnalyticsEvent) GetProfileEdit() *ProfileEditEvent {
	if m != nil {
		return m.ProfileEdit
	}
	return nil
}

func (m *AnalyticsEvent) GetPromo() *PromoEvent {
	if m != nil {
		return m.Promo
	}
	return nil
}

func (m *AnalyticsEvent) GetXAppShow() *CrossAppShowEvent {
	if m != nil {
		return m.XAppShow
	}
	return nil
}

func (m *AnalyticsEvent) GetXAppClick() *CrossAppClickEvent {
	if m != nil {
		return m.XAppClick
	}
	return nil
}

func (m *AnalyticsEvent) GetStateChange() *StateChangeEvent {
	if m != nil {
		return m.StateChange
	}
	return nil
}

func (m *AnalyticsEvent) GetSetup() *SetupEvent {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *AnalyticsEvent) GetClick() *ClickEvent {
	if m != nil {
		return m.Click
	}
	return nil
}

func (m *AnalyticsEvent) GetLoginSession() *LoginSessionEvent {
	if m != nil {
		return m.LoginSession
	}
	return nil
}

func (m *AnalyticsEvent) GetConnect() *ConnectEvent {
	if m != nil {
		return m.Connect
	}
	return nil
}

// A batch of events.
type EventBatch struct {
	// Millisecond Unix timestamp.
	ClientSendTime   *int64            `protobuf:"varint,1,opt,name=client_send_time,json=clientSendTime" json:"client_send_time,omitempty"`
	Events           []*AnalyticsEvent `protobuf:"bytes,2,rep,name=events" json:"events,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *EventBatch) Reset()                    { *m = EventBatch{} }
func (m *EventBatch) String() string            { return proto.CompactTextString(m) }
func (*EventBatch) ProtoMessage()               {}
func (*EventBatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *EventBatch) GetClientSendTime() int64 {
	if m != nil && m.ClientSendTime != nil {
		return *m.ClientSendTime
	}
	return 0
}

func (m *EventBatch) GetEvents() []*AnalyticsEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func init() {
	proto.RegisterType((*EventMetadata)(nil), "generated.EventMetadata")
	proto.RegisterType((*DeviceInfo)(nil), "generated.DeviceInfo")
	proto.RegisterType((*UserProperties)(nil), "generated.UserProperties")
	proto.RegisterType((*PlayerState)(nil), "generated.PlayerState")
	proto.RegisterType((*Counter)(nil), "generated.Counter")
	proto.RegisterType((*SessionEvent)(nil), "generated.SessionEvent")
	proto.RegisterType((*LevelEvent)(nil), "generated.LevelEvent")
	proto.RegisterType((*LoginEvent)(nil), "generated.LoginEvent")
	proto.RegisterType((*LoginSessionEvent)(nil), "generated.LoginSessionEvent")
	proto.RegisterType((*ProfileEditEvent)(nil), "generated.ProfileEditEvent")
	proto.RegisterType((*ConnectEvent)(nil), "generated.ConnectEvent")
	proto.RegisterType((*ClickEvent)(nil), "generated.ClickEvent")
	proto.RegisterType((*SetupEvent)(nil), "generated.SetupEvent")
	proto.RegisterType((*PromoEvent)(nil), "generated.PromoEvent")
	proto.RegisterType((*CrossAppShowEvent)(nil), "generated.CrossAppShowEvent")
	proto.RegisterType((*CrossAppClickEvent)(nil), "generated.CrossAppClickEvent")
	proto.RegisterType((*StateChangeEvent)(nil), "generated.StateChangeEvent")
	proto.RegisterType((*TimedData)(nil), "generated.TimedData")
	proto.RegisterType((*InLevelData)(nil), "generated.InLevelData")
	proto.RegisterType((*AnalyticsEvent)(nil), "generated.AnalyticsEvent")
	proto.RegisterType((*EventBatch)(nil), "generated.EventBatch")
	proto.RegisterEnum("generated.EventMetadata_Source", EventMetadata_Source_name, EventMetadata_Source_value)
}

func init() { proto.RegisterFile("AnalyticsEvent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1849 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x57, 0xcd, 0x6e, 0x23, 0x59,
	0x15, 0x96, 0xd3, 0xf1, 0xdf, 0xb1, 0x93, 0x71, 0xdf, 0xe9, 0xee, 0xa9, 0x61, 0x66, 0x34, 0x60,
	0x04, 0x1a, 0xf5, 0x88, 0xa0, 0x69, 0x18, 0x21, 0x40, 0x20, 0xb9, 0x1d, 0xd3, 0x13, 0xd1, 0x4e,
	0xc2, 0x75, 0x9a, 0x16, 0xab, 0x52, 0x75, 0xd5, 0x4d, 0x5c, 0x9d, 0x72, 0x55, 0x4d, 0xfd, 0x38,
	0x89, 0x58, 0xc0, 0x13, 0xb0, 0x64, 0xc1, 0x8a, 0x0d, 0x62, 0xcf, 0xb3, 0xf0, 0x0e, 0xb0, 0xe1,
	0x1d, 0x38, 0x3f, 0xb7, 0xca, 0x95, 0x78, 0x3a, 0x1a, 0xaf, 0x7c, 0xbe, 0xfb, 0xdd, 0x73, 0xcf,
	0x3d, 0xbf, 0xb7, 0xe0, 0xd1, 0x24, 0xf6, 0xa2, 0x9b, 0x22, 0xf4, 0xf3, 0xd9, 0xda, 0xc4, 0xc5,
	0x41, 0x9a, 0x25, 0x45, 0xa2, 0xfa, 0x17, 0x26, 0x36, 0x99, 0x57, 0x98, 0x60, 0xfc, 0x97, 0x5d,
	0xd8, 0xe3, 0xa5, 0xb9, 0x29, 0xbc, 0xc0, 0x2b, 0x3c, 0xf5, 0x33, 0xe8, 0xe4, 0x49, 0x99, 0xf9,
	0xc6, 0x69, 0x7d, 0xb7, 0xf5, 0xd9, 0xfe, 0xb3, 0x4f, 0x0f, 0x6a, 0xf6, 0xc1, 0x2d, 0xe6, 0xc1,
	0x82, 0x69, 0xda, 0xd2, 0xd5, 0x0f, 0x60, 0x5f, 0xfe, 0xb9, 0x6b, 0x93, 0xe5, 0x61, 0x12, 0x3b,
	0x3b, 0xa8, 0xa0, 0xaf, 0xf7, 0x04, 0xfd, 0xbd, 0x80, 0xea, 0x13, 0x80, 0xdc, 0xe4, 0xf4, 0xd7,
	0x0d, 0x03, 0xe7, 0x01, 0x52, 0x1e, 0xe8, 0xbe, 0x45, 0x8e, 0x02, 0xf5, 0x7d, 0xd8, 0x33, 0x74,
	0x8a, 0xeb, 0x27, 0x65, 0x5c, 0x98, 0xcc, 0xd9, 0x45, 0x46, 0x5b, 0x0f, 0x19, 0x9c, 0x0a, 0xa6,
	0x3e, 0x80, 0x6e, 0x99, 0x9b, 0x8c, 0x14, 0x74, 0xf8, 0x8c, 0x0e, 0x89, 0xb8, 0x1b, 0x95, 0xe3,
	0x15, 0xcf, 0xc3, 0xc8, 0xd0, 0x5a, 0x97, 0xd7, 0xfa, 0x16, 0xc1, 0xe5, 0x8f, 0xa0, 0x1f, 0x98,
	0x75, 0xe8, 0xf3, 0x6a, 0x8f, 0x57, 0x7b, 0x02, 0xe0, 0xe2, 0xa7, 0x30, 0x58, 0x85, 0xd7, 0xa9,
	0x17, 0x9b, 0x88, 0x96, 0xfb, 0xbc, 0x0c, 0x15, 0x24, 0x04, 0x3f, 0x0a, 0xc9, 0xb6, 0x22, 0x5c,
	0x19, 0x07, 0xd8, 0x74, 0x10, 0xe8, 0x0c, 0x11, 0x22, 0xa0, 0x19, 0x78, 0x7b, 0x21, 0x0c, 0x84,
	0x20, 0x10, 0x11, 0xc6, 0x7f, 0x6f, 0x41, 0x47, 0xbc, 0xa6, 0x86, 0xd0, 0x3b, 0x7d, 0x39, 0xf9,
	0xc3, 0xc9, 0x62, 0x7e, 0x32, 0x6a, 0x29, 0x80, 0xce, 0x5c, 0xfe, 0xef, 0xa8, 0x11, 0x0c, 0x5f,
	0x4c, 0xe6, 0x33, 0xf7, 0x6c, 0x72, 0xfc, 0x42, 0x4f, 0xe6, 0x23, 0xa3, 0xf6, 0x01, 0x18, 0x79,
	0x7d, 0xa2, 0x0f, 0x17, 0xa3, 0x73, 0xf5, 0x1e, 0x0c, 0x58, 0x3e, 0x9e, 0xbd, 0x3e, 0x3b, 0x39,
	0x1e, 0x5d, 0xa8, 0x47, 0x30, 0x62, 0x60, 0x3e, 0x59, 0x9c, 0xcd, 0xf4, 0xe9, 0xd1, 0x6c, 0x3a,
	0x1b, 0x2d, 0x6b, 0x45, 0xc7, 0xaf, 0xe6, 0xcf, 0x67, 0x7a, 0x31, 0x0a, 0xeb, 0x8d, 0xd3, 0x93,
	0xc3, 0xa3, 0xe3, 0x17, 0xa3, 0xb7, 0x35, 0x65, 0x7e, 0x72, 0x4c, 0x3b, 0x47, 0x97, 0xe3, 0x7f,
	0xb5, 0x00, 0x0e, 0xc5, 0x25, 0xf1, 0x79, 0xa2, 0xbe, 0x03, 0xbd, 0x34, 0xf2, 0x8a, 0xf3, 0x24,
	0x5b, 0x71, 0x3e, 0xa0, 0xc3, 0x2a, 0x19, 0x4f, 0x6d, 0xaf, 0x92, 0xc0, 0x44, 0x36, 0xce, 0x22,
	0xa0, 0xb1, 0x3b, 0x49, 0xce, 0x71, 0xed, 0x6b, 0xfc, 0xa7, 0xbe, 0x07, 0xc3, 0xdc, 0xcf, 0x8c,
	0x89, 0xdd, 0xab, 0x30, 0x28, 0x96, 0x36, 0x9e, 0x03, 0xc1, 0x5e, 0x13, 0x44, 0x31, 0xb7, 0x94,
	0xa5, 0x09, 0x2f, 0x96, 0x85, 0xd3, 0x96, 0x98, 0x0b, 0xf8, 0x15, 0x63, 0x64, 0x49, 0xe4, 0xc5,
	0x17, 0xa5, 0x77, 0x61, 0x6c, 0xd0, 0x6b, 0x79, 0xfc, 0xd7, 0x5d, 0xd8, 0x7f, 0x85, 0x7e, 0x3e,
	0xcd, 0x92, 0xd4, 0x64, 0x45, 0x68, 0x72, 0xca, 0x84, 0xa5, 0xb7, 0x36, 0x6e, 0x6e, 0x8a, 0x32,
	0x65, 0xd3, 0x7b, 0xba, 0x4f, 0xc8, 0x82, 0x00, 0x3a, 0x32, 0xf2, 0xf2, 0xc2, 0xad, 0x55, 0xca,
	0x1d, 0x86, 0x04, 0xbe, 0xb4, 0x18, 0x91, 0x58, 0xc7, 0xd2, 0xcb, 0x82, 0x2b, 0x2f, 0x33, 0x7c,
	0xab, 0x9e, 0x1e, 0x12, 0xf8, 0x95, 0xc5, 0xd4, 0x01, 0xbc, 0xcf, 0x24, 0x73, 0x5d, 0x64, 0xde,
	0x86, 0xba, 0xcb, 0xd4, 0x87, 0xb4, 0x34, 0xa3, 0x95, 0x9a, 0x4f, 0x97, 0xb5, 0xf9, 0xcf, 0x29,
	0x5e, 0x5f, 0x56, 0x40, 0x4e, 0x71, 0xca, 0x24, 0x74, 0xf3, 0x0d, 0xa5, 0x91, 0xbb, 0xca, 0xf9,
	0xbe, 0x6d, 0x0d, 0x15, 0x34, 0x67, 0xaf, 0x46, 0x58, 0x12, 0x51, 0xc5, 0xe8, 0x8a, 0x57, 0x6b,
	0xac, 0x41, 0x71, 0xf3, 0xc2, 0xcb, 0x8a, 0x9c, 0xf3, 0xbd, 0xa2, 0x2c, 0x18, 0x22, 0x27, 0x09,
	0xc5, 0xc4, 0x41, 0xce, 0x19, 0xdf, 0xd6, 0x7d, 0x46, 0x66, 0x08, 0x70, 0xf0, 0xa5, 0x76, 0x72,
	0xce, 0xf6, 0xb6, 0xae, 0x65, 0xb2, 0x90, 0x1d, 0xb8, 0x0a, 0xb3, 0x2c, 0xc9, 0x38, 0xd7, 0xd1,
	0x42, 0x82, 0xe6, 0x8c, 0xa8, 0xcf, 0x60, 0xc4, 0x04, 0x0e, 0x80, 0x1b, 0x98, 0x37, 0xe5, 0x85,
	0x33, 0x64, 0x27, 0xef, 0x13, 0xce, 0x61, 0x38, 0x24, 0x54, 0xfd, 0x18, 0xde, 0xf7, 0xfc, 0x65,
	0x88, 0xc7, 0xae, 0xb0, 0x92, 0x72, 0x17, 0x63, 0x18, 0x9b, 0xc0, 0xd9, 0x63, 0x95, 0xaa, 0xb9,
	0x74, 0xc2, 0x2b, 0x6c, 0x36, 0xab, 0x2e, 0xb0, 0x2b, 0x39, 0xfb, 0x52, 0xe5, 0xac, 0x94, 0x80,
	0xa7, 0xfd, 0xde, 0x7f, 0xbb, 0xa3, 0x3f, 0xe3, 0x6f, 0x67, 0x7c, 0x02, 0x83, 0x53, 0x74, 0x9a,
	0xc9, 0x78, 0x45, 0x7d, 0x09, 0x4f, 0x6e, 0x9d, 0xe4, 0x27, 0xab, 0x34, 0x32, 0xd8, 0xd9, 0x38,
	0x41, 0xda, 0xfa, 0x71, 0x73, 0x75, 0x5a, 0x2d, 0x36, 0x15, 0xfe, 0x04, 0xba, 0x55, 0x13, 0x52,
	0xb0, 0x1b, 0x7b, 0x2b, 0x63, 0xcb, 0x82, 0xff, 0x53, 0x49, 0x48, 0x50, 0x77, 0x58, 0x9f, 0x08,
	0xe3, 0xff, 0xec, 0xc0, 0x70, 0x21, 0xe1, 0xe5, 0x0e, 0xaa, 0x7e, 0x04, 0x1d, 0x69, 0x3b, 0xbc,
	0x79, 0xf0, 0xec, 0x71, 0xa3, 0xc7, 0x6e, 0x8a, 0x4f, 0x5b, 0x92, 0xfa, 0x25, 0x0c, 0xd1, 0xef,
	0x69, 0xee, 0x16, 0x09, 0xb9, 0x93, 0x95, 0x0f, 0x9e, 0x7d, 0xd8, 0xd8, 0x74, 0x3b, 0xf9, 0x35,
	0x30, 0xfd, 0x2c, 0x41, 0x27, 0xab, 0x17, 0xa0, 0xea, 0xcd, 0x61, 0x8c, 0x15, 0x45, 0x97, 0xe3,
	0x4c, 0xbe, 0x57, 0xc5, 0xc8, 0xaa, 0x38, 0xaa, 0xb6, 0xa8, 0x9f, 0xa3, 0x15, 0xec, 0x4b, 0xeb,
	0xf7, 0x5d, 0x56, 0xf1, 0xa4, 0xa1, 0xa2, 0xe1, 0x6a, 0x3d, 0x48, 0x1b, 0x7e, 0xbf, 0x9b, 0xad,
	0xed, 0xed, 0x6c, 0xbd, 0xa7, 0xbc, 0xef, 0xc4, 0xbb, 0x7b, 0x4f, 0xbc, 0x33, 0x80, 0x97, 0x9c,
	0xbe, 0xec, 0xe6, 0x1f, 0xc2, 0x7b, 0x92, 0xde, 0x65, 0x1c, 0x7e, 0x5d, 0x72, 0xd3, 0x6f, 0x71,
	0x4f, 0xde, 0x63, 0xf8, 0x15, 0xa3, 0xd8, 0xd8, 0x3f, 0xc4, 0xb3, 0x99, 0x87, 0x04, 0xe9, 0x03,
	0x5d, 0x96, 0x71, 0xe9, 0x09, 0x4d, 0xc3, 0x68, 0x6d, 0x02, 0x5b, 0xfb, 0x56, 0x6a, 0x9e, 0xf9,
	0x47, 0x3c, 0x33, 0xb9, 0x08, 0x6d, 0x68, 0x9f, 0xdc, 0x1a, 0x9f, 0xfd, 0x7a, 0x3a, 0x3a, 0xd0,
	0xcd, 0x4c, 0x5e, 0xae, 0x8c, 0x1c, 0xd1, 0xd3, 0x95, 0x48, 0x2b, 0x79, 0xe9, 0xfb, 0x98, 0x1f,
	0xf6, 0x8c, 0x4a, 0x24, 0xb7, 0xc5, 0xe5, 0xca, 0xf5, 0x7c, 0x4e, 0xa3, 0xbc, 0x6a, 0x9d, 0x88,
	0x4d, 0x2c, 0x34, 0xfe, 0x47, 0x0b, 0x1e, 0xf2, 0xe9, 0xb7, 0xf2, 0xeb, 0x5d, 0x46, 0xa0, 0x93,
	0xbd, 0xa2, 0x30, 0xab, 0x14, 0x95, 0x49, 0x86, 0xd6, 0xf2, 0x3d, 0x66, 0xa0, 0x36, 0x3f, 0x4a,
	0x72, 0xb4, 0x5c, 0x9a, 0x9a, 0x95, 0xd4, 0x53, 0xe8, 0x18, 0x2a, 0x75, 0x8a, 0xe7, 0x03, 0x4c,
	0x05, 0xd5, 0x48, 0x05, 0x5b, 0x24, 0xda, 0x32, 0xc6, 0xff, 0x6c, 0xc1, 0xe8, 0x54, 0x7a, 0xc7,
	0x2c, 0x08, 0x8b, 0xda, 0x4c, 0x1c, 0x24, 0xbe, 0x2d, 0x3f, 0x54, 0x2c, 0x12, 0xf5, 0x96, 0xd8,
	0x5c, 0xb9, 0xb6, 0xd7, 0x58, 0x7f, 0x01, 0x42, 0x56, 0x03, 0x6d, 0xf4, 0xd6, 0xf8, 0x04, 0xc9,
	0xd8, 0xd4, 0xb6, 0xb6, 0x92, 0x94, 0x5f, 0x94, 0x54, 0x8f, 0x06, 0x11, 0xa8, 0x50, 0xf3, 0xc2,
	0xa4, 0x9c, 0x75, 0x58, 0xa8, 0xf4, 0x9f, 0x6e, 0xeb, 0x27, 0xf1, 0x79, 0x88, 0x63, 0xad, 0x23,
	0xb7, 0xb5, 0xe2, 0xf8, 0x7f, 0x2d, 0x18, 0x4e, 0x93, 0x38, 0x36, 0xbe, 0xb5, 0x92, 0x9c, 0x56,
	0x16, 0x74, 0x70, 0x64, 0xed, 0xac, 0x65, 0x7a, 0x50, 0xe0, 0xcb, 0x23, 0xc0, 0xc2, 0x3a, 0x4f,
	0x2a, 0x8f, 0x12, 0xc0, 0xb3, 0xb3, 0x5a, 0xcc, 0x2f, 0xc3, 0xd4, 0x1a, 0xca, 0x8b, 0x0b, 0x94,
	0x69, 0x0c, 0xc4, 0xa6, 0xb8, 0x4a, 0xb2, 0x4b, 0xf7, 0xdc, 0x0b, 0xa3, 0x2a, 0xb8, 0x43, 0x0b,
	0xfe, 0x86, 0x30, 0x22, 0x85, 0xf1, 0xda, 0x8b, 0xc2, 0xc0, 0x92, 0xec, 0xac, 0xb0, 0x60, 0x4d,
	0x2a, 0xe3, 0xcb, 0x38, 0xb9, 0x8a, 0x2d, 0x49, 0xa6, 0xc5, 0xd0, 0x82, 0x42, 0x6a, 0x44, 0xb7,
	0x7b, 0x2b, 0xba, 0xe3, 0x97, 0x00, 0xd3, 0x28, 0xf4, 0x2f, 0xe5, 0xb2, 0xe8, 0xfa, 0xe4, 0xcd,
	0x5b, 0xd7, 0x27, 0xc4, 0xc6, 0x05, 0x1f, 0x41, 0x08, 0x4d, 0x05, 0xa1, 0x5a, 0xf4, 0x4b, 0x6c,
	0x01, 0x3c, 0x9a, 0x6d, 0xb5, 0xf4, 0x11, 0x59, 0x30, 0x30, 0xfe, 0x1b, 0x3e, 0x1f, 0xb8, 0xb5,
	0x8b, 0x3a, 0x1a, 0xfe, 0xdc, 0xff, 0xa9, 0x74, 0xcb, 0xdc, 0xea, 0x1b, 0x30, 0xb6, 0x60, 0x88,
	0x28, 0xa9, 0x97, 0xda, 0xae, 0x52, 0xe6, 0x56, 0xe5, 0x80, 0x31, 0x4b, 0xc1, 0x97, 0xa5, 0x8c,
	0x19, 0xf7, 0xeb, 0x12, 0xef, 0x5d, 0xdc, 0x58, 0x6f, 0xee, 0x09, 0xfa, 0x3b, 0x01, 0xe5, 0xf9,
	0xb5, 0x19, 0x36, 0xbb, 0x62, 0x7b, 0x5e, 0x0f, 0x9a, 0xf1, 0x9f, 0x00, 0x30, 0x83, 0x56, 0x89,
	0xd8, 0x86, 0xe1, 0x49, 0x49, 0x72, 0x2f, 0xcd, 0x4d, 0xfd, 0xb6, 0x21, 0xe0, 0xb7, 0xe6, 0x86,
	0x72, 0xa6, 0xf0, 0xd2, 0xaa, 0x4a, 0xf8, 0x3f, 0x65, 0xd7, 0x3a, 0x34, 0x57, 0xb9, 0x3d, 0x5d,
	0x04, 0xa9, 0x0e, 0xf4, 0x4d, 0x15, 0x41, 0x2b, 0x91, 0x06, 0x4a, 0x13, 0x1b, 0x32, 0xfe, 0x3f,
	0x7e, 0x0a, 0x0f, 0xa7, 0x59, 0x92, 0xe7, 0x93, 0x34, 0x5d, 0x2c, 0x93, 0x2b, 0xb1, 0xe3, 0x31,
	0x26, 0x73, 0x9a, 0x56, 0xcd, 0x09, 0xdf, 0x51, 0x28, 0x1d, 0x05, 0xe3, 0xcf, 0x41, 0x55, 0xdc,
	0x46, 0x7c, 0xde, 0x41, 0x3e, 0x86, 0x11, 0xf7, 0xc2, 0xe9, 0x12, 0x7b, 0xa6, 0xa9, 0xef, 0x47,
	0x55, 0x24, 0x4d, 0xd3, 0xde, 0x0f, 0x01, 0xe9, 0xc8, 0xfc, 0x50, 0x36, 0x6b, 0xbb, 0xba, 0x53,
	0x3d, 0x94, 0xcd, 0x9a, 0x97, 0xc7, 0x09, 0xf4, 0xe9, 0xc1, 0x1a, 0x1c, 0xd2, 0x17, 0x01, 0xfa,
	0x35, 0x28, 0xb1, 0xac, 0xe9, 0xc9, 0xb2, 0xca, 0xed, 0xa8, 0x84, 0x0a, 0xc2, 0xde, 0xfd, 0x31,
	0xf4, 0x37, 0x93, 0x54, 0xaa, 0x75, 0x03, 0x50, 0x7e, 0x72, 0xdf, 0xcf, 0x0c, 0x7e, 0x36, 0xbc,
	0x89, 0x8c, 0x7d, 0x1b, 0x0e, 0x09, 0xd4, 0x16, 0x1b, 0x7f, 0x09, 0x83, 0xa3, 0x98, 0x5b, 0x37,
	0x1f, 0xf9, 0x2d, 0x3b, 0xf7, 0xf8, 0xdf, 0x1d, 0xd8, 0xbf, 0xfd, 0x89, 0xa3, 0x7e, 0x0a, 0xbd,
	0x95, 0xfd, 0x42, 0xb1, 0xd3, 0xd5, 0x79, 0xd7, 0x17, 0x8c, 0xae, 0x99, 0xe4, 0x0f, 0xf9, 0xec,
	0x28, 0x6e, 0xd2, 0xda, 0x1f, 0x8c, 0x9c, 0x21, 0x80, 0xad, 0xae, 0x4d, 0xe6, 0x06, 0x76, 0x6e,
	0x3e, 0x6a, 0x68, 0xac, 0xfd, 0xa4, 0x85, 0xa2, 0xbe, 0x80, 0x5e, 0x18, 0xbb, 0x6c, 0xe7, 0x37,
	0xcc, 0xc8, 0xc6, 0x2d, 0x75, 0x37, 0x14, 0x01, 0xb7, 0x74, 0xed, 0xf3, 0xcf, 0x09, 0x78, 0xc7,
	0x07, 0x8d, 0x1d, 0xcd, 0xce, 0xae, 0x2b, 0x9e, 0xfa, 0x1c, 0xda, 0x72, 0x84, 0xd9, 0x7a, 0x41,
	0x6c, 0x26, 0xa0, 0x16, 0x0e, 0x93, 0x69, 0x48, 0x38, 0xe7, 0xdb, 0xe4, 0x7a, 0x74, 0x69, 0xe1,
	0xa8, 0x5f, 0xf3, 0x6b, 0x83, 0xbf, 0xa1, 0x0c, 0xb6, 0x6a, 0xe7, 0x82, 0xf7, 0x7c, 0xd4, 0x9c,
	0xf3, 0x77, 0x1a, 0x39, 0x56, 0xeb, 0x06, 0xa1, 0xc3, 0xb8, 0x8c, 0x9c, 0xe5, 0xd6, 0x61, 0x9b,
	0xea, 0xd3, 0xc2, 0x51, 0xbf, 0x00, 0xb8, 0x76, 0x29, 0xa3, 0x73, 0xac, 0x07, 0x27, 0xe4, 0x1d,
	0x1f, 0x37, 0xe7, 0xc8, 0xdd, 0x72, 0xd1, 0xbd, 0x6b, 0x2b, 0xaa, 0x5f, 0xc1, 0x40, 0xf6, 0x72,
	0xc5, 0x39, 0x6f, 0x79, 0xf3, 0x27, 0xdf, 0xb0, 0x79, 0x53, 0x3f, 0xba, 0x7f, 0x5d, 0xc9, 0x74,
	0x4f, 0xce, 0x7e, 0xd7, 0xe7, 0xa2, 0x71, 0x2e, 0xb7, 0xee, 0x79, 0xb7, 0xa4, 0xb0, 0x71, 0x6d,
	0x10, 0xba, 0xa7, 0x7c, 0x5c, 0x44, 0x5b, 0xf7, 0xdc, 0x74, 0x40, 0x2d, 0x1c, 0x22, 0x8b, 0x95,
	0xab, 0x2d, 0x72, 0xc3, 0x3a, 0xe1, 0xa8, 0x09, 0x7e, 0x9c, 0x50, 0x28, 0xdc, 0x2a, 0x29, 0xe2,
	0x2d, 0xbf, 0x6c, 0xcd, 0x7c, 0xfc, 0x74, 0x69, 0x40, 0x94, 0x51, 0xbe, 0x0c, 0x31, 0x27, 0xd9,
	0xca, 0xa8, 0xe6, 0x78, 0xd3, 0x15, 0xaf, 0xf9, 0xa4, 0x09, 0x01, 0x78, 0xf1, 0xb9, 0x57, 0xf8,
	0x4b, 0x7a, 0xc9, 0xdb, 0xef, 0xde, 0x1c, 0xbf, 0x13, 0xe4, 0xdb, 0x56, 0xaa, 0x71, 0x5f, 0xf0,
	0x05, 0xc2, 0xfc, 0x01, 0xfc, 0x05, 0xbe, 0x08, 0x68, 0x1f, 0xf5, 0xcd, 0x07, 0x77, 0xde, 0x97,
	0xb7, 0xcb, 0x54, 0x5b, 0xe2, 0xf3, 0xc1, 0xf3, 0x7e, 0xbd, 0xf2, 0xff, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xa1, 0x38, 0x4f, 0xb5, 0xaf, 0x10, 0x00, 0x00,
}
